import 'package:flutter/material.dart';
import 'package:nvs/meatup_core.dart';

// Placeholder model for an astrological aspect
class SynastryAspect {
  // e.g., "Square", "Trine"
  SynastryAspect({
    required this.planet1,
    required this.planet2,
    required this.aspectType,
  });
  final String planet1;
  final String planet2;
  final String aspectType;
}

class SynastryProjector extends StatefulWidget {
  const SynastryProjector({required this.aspects, super.key});
  // In a real scenario, this list would be generated by our astrology library
  final List<SynastryAspect> aspects;

  @override
  State<SynastryProjector> createState() => _SynastryProjectorState();
}

class _SynastryProjectorState extends State<SynastryProjector> with SingleTickerProviderStateMixin {
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    )..forward();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: <Widget>[
        const Text(
          'ENERGETIC SYNASTRY',
          style: TextStyle(
            color: NVSColors.secondaryText,
            fontSize: 14,
            letterSpacing: 4,
          ),
        ),
        SizedBox(
          height: 300,
          child: CustomPaint(
            size: Size.infinite,
            painter: _SynastryPainter(
              aspects: widget.aspects,
              animationValue: _controller.value,
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceAround,
              children: <Widget>[
                _buildAvatar(
                  'YOU',
                  'assets/images/avatar_placeholder.png',
                ),
                _buildAvatar(
                  'THEM',
                  'assets/images/avatar_placeholder.png',
                ),
              ],
            ),
          ),
        ),
        // We'll add a summary text here later
      ],
    );
  }

  Widget _buildAvatar(String label, String url) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: <Widget>[
        CircleAvatar(
          radius: 50,
          backgroundImage:
              url.startsWith('http') ? NetworkImage(url) : AssetImage(url) as ImageProvider,
        ),
        const SizedBox(height: 8),
        Text(
          label,
          style: const TextStyle(color: NVSColors.secondaryText, letterSpacing: 2),
        ),
      ],
    );
  }
}

class _SynastryPainter extends CustomPainter {
  // 0.0 to 1.0

  _SynastryPainter({required this.aspects, required this.animationValue});
  final List<SynastryAspect> aspects;
  final double animationValue;

  // A map to give each planet a vertical position on the canvas
  final Map<String, double> planetPositions = <String, double>{
    'Sun': 0.1,
    'Moon': 0.2,
    'Mars': 0.3,
    'Venus': 0.4,
    'Saturn': 0.5,
  };

  @override
  void paint(Canvas canvas, Size size) {
    final Paint paint = Paint()..strokeWidth = 1.5;

    final double startX = size.width * 0.25;
    final double endX = size.width * 0.75;

    for (final SynastryAspect aspect in aspects) {
      // Determine color based on aspect type
      final bool isHarmonious = aspect.aspectType == 'Trine' || aspect.aspectType == 'Sextile';
      paint.color = isHarmonious ? NVSColors.primaryNeonMint : Colors.red.withValues(alpha: 0.8);
      paint.shader = isHarmonious
          ? RadialGradient(
              colors: <Color>[
                NVSColors.primaryNeonMint.withValues(alpha: 0.8),
                NVSColors.primaryNeonMint.withValues(alpha: 0.2),
              ],
            ).createShader(Rect.fromLTWH(0, 0, size.width, size.height))
          : null;

      final double startY = size.height * (planetPositions[aspect.planet1] ?? 0);
      final double endY = size.height * (planetPositions[aspect.planet2] ?? 0);

      if (startY > 0 && endY > 0) {
        // We use the animationValue to "draw" the line across the screen
        final double animatedEndX = startX + (endX - startX) * animationValue;
        canvas.drawLine(
          Offset(startX, startY),
          Offset(animatedEndX, endY),
          paint,
        );
      }
    }
  }

  @override
  bool shouldRepaint(covariant _SynastryPainter oldDelegate) {
    return animationValue != oldDelegate.animationValue;
  }
}
